= API Levels
:doctype: book
:icons: font
:source-highlighter: highlight.js
:toc: left
:toclevels: 3

include::_attributes.adoc[]

{project-name} is organized as a layered library.
At the bottom sits the immediate-mode API for direct terminal control.
On top of that, TuiRunner adds a managed event loop.
At the highest level, the Toolkit DSL provides a declarative, component-based approach.

You can use any layer directly, or mix them as needed.

[cols="1,2,1",options="header"]
|===
|API |Description |Use When

|<<immediate-mode,Immediate Mode>>
|Direct terminal control - you manage the event loop, drawing, and all state
|Building custom backends, game engines, or learning how things work

|<<tuirunner,TuiRunner>>
|Managed event loop with callbacks for events and rendering
|Custom event handling, animations, widget-based UIs without Toolkit

|<<toolkit-dsl,Toolkit DSL>>
|Declarative, component-based UI with fluent builders
|Most applications - fastest path to a working UI

|<<inline-display-mode,Inline Display>>
|Fixed status area that preserves terminal scroll history
|Low-level inline control, custom rendering

|<<inline-tui-runner,Inline TUI Runner>>
|Managed event loop for inline displays with key/mouse handling
|Inline apps needing event handling without full Toolkit

|<<inline-toolkit,Inline Toolkit>>
|Declarative element-based inline displays
|Most inline applications - NPM/Gradle-style progress UIs
|===

== Immediate Mode

Direct control over the terminal backend, the buffer, and the event loop.
Nothing is hidden - you decide when to poll for events, when to draw, and how to structure your main loop.

=== Terminal and Backend

The `Terminal` wraps a `Backend` that handles the actual terminal I/O:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=terminal-and-backend]
----

Before you can draw anything useful, you need to set up the terminal:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=backend-setup]
----

The try-with-resources pattern ensures cleanup happens automatically.
If you're not using it, remember to restore the terminal state before exiting.

=== Drawing

All rendering goes through `terminal.draw()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=drawing]
----

The `Frame` gives you:

- `area()` - the full renderable region
- `buffer()` - direct access to the cell grid
- `renderWidget()` / `renderStatefulWidget()` - render widgets to specific areas

For pixel-level control, work with the buffer directly:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=buffer-manipulation]
----

=== Putting It Together

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=immediate-mode-example]
----

This is verbose, but you have complete control.
For most applications, you'll want one of the higher-level APIs.

== TuiRunner

TuiRunner takes over terminal setup and the event loop.
You provide two callbacks: one for handling events, one for rendering.

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=tui-runner-basic]
----

The event handler returns `true` to request a redraw, `false` otherwise.
This avoids unnecessary redraws when nothing changed.

=== Configuration

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=tui-config]
----

Tick events fire at the configured rate - useful for animations, clocks, or any periodic updates.

==== Disabling Ticks

For purely event-driven UIs that only need to refresh on user input, you can disable ticks:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=tui-no-tick]
----

Even with ticks disabled, the UI automatically redraws on terminal resize within the configured grace period (default 250ms).
You can customize this:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=tui-resize-grace-period]
----

Set `resizeGracePeriod(null)` to disable automatic resize handling entirely (not recommended).

=== Error Handling

When exceptions occur during rendering, TuiRunner catches them and displays an error screen with the stack trace.
By default, errors are shown in-app with options to scroll and dismiss:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=error-handling-default]
----

Configure error handling behavior via `TuiConfig`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=error-handler-config]
----

Available error handlers:

[cols="1,2",options="header"]
|===
|Handler |Behavior

|`displayAndQuit()` (default)
|Shows full-screen error display with scrollable stack trace, quit on 'q'

|`logAndQuit(PrintStream)`
|Logs error to stream, then exits immediately

|`writeToFile(Path)`
|Writes error to file, then shows in-app display

|`suppress()`
|Logs warning and continues (use with caution)
|===

Custom error handlers implement `RenderErrorHandler`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=custom-error-handler]
----

=== Threading Model

{project-name} uses a dedicated *render thread model* similar to other UI frameworks.
All rendering and UI state modifications must happen on the render thread - the thread running `TuiRunner.run()`.

This model provides:

* **Thread safety**: No locks needed in UI code since everything runs on one thread
* **Predictable behavior**: UI updates happen in a well-defined order
* **Clear error reporting**: Wrong-thread access throws `IllegalStateException` with diagnostic info

==== The render thread

When `TuiRunner.run()` starts, it marks the current thread as the render thread.
All event handling and rendering callbacks execute on this thread.
When `run()` exits, the render thread is cleared.

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=render-thread-check]
----

==== Updating UI from Background Threads

To safely update UI state from background threads (network callbacks, timers, async tasks), use `runOnRenderThread()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=run-on-render-thread]
----

If called from the render thread, the action executes immediately.
If called from another thread, it's queued and runs during the next event loop iteration.

For actions that should always be deferred (even when on render thread), use `runLater()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=run-later]
----

==== Scheduled Actions

Scheduled actions via `ToolkitRunner.schedule()`, `scheduleRepeating()`, and `scheduleWithFixedDelay()` run on the scheduler thread.
If they modify UI state, use `runOnRenderThread()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=scheduled-actions]
----

This explicit approach gives you control - you can do background work in the scheduled action and only post the UI update portion to the render thread.

==== Scheduler Management

Each runner maintains a single shared scheduler that handles both internal tasks (tick events, resize detection) and user-scheduled actions.
By default, this scheduler is created internally when the runner starts and shut down when the runner closes.

===== External Scheduler Injection

For integration with frameworks that provide their own thread pools, you can inject an external scheduler via configuration:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=external-scheduler-injection]
----

===== Closing Semantics

When closing runners:

* **Internally-created scheduler**: Shut down automatically when the runner closes
* **Externally-provided scheduler**: NOT shut down - the caller retains ownership and is responsible for its lifecycle

This allows frameworks to manage scheduler lifecycles independently of individual runner instances.

===== Multiple Runners

When using multiple runners in a single application (e.g., multiple `InlineTuiRunner` instances for different inline displays), there are two approaches:

[cols="1,2",options="header"]
|===
|Approach |Behavior

|Default (no external scheduler)
|Each runner creates and owns its own scheduler. Closing one runner shuts down only its scheduler.

|Shared external scheduler
|All runners share the provided scheduler. Runners do not shut it down; the caller manages its lifecycle.
|===

For multiple runners that should share a scheduler, provide an externally-managed scheduler via config to avoid premature shutdown when one runner closes.

=== Semantic Key Checks

`KeyEvent` provides semantic methods that respect the configured bindings:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=semantic-key-checks]
----

These delegate to the link:bindings.html[bindings system] - with vim bindings, `isUp()` matches `k`, with standard bindings it only matches the Up arrow.

=== Event Handling Patterns

Pattern matching works well with the event types:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=event-pattern-matching]
----

=== Layout in the Renderer

The renderer callback receives a `Frame`, just like immediate mode.
Combine it with the layout system:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=layout-in-renderer]
----

=== Example: Counter with Animation

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=counter-demo]
----

TuiRunner hits a sweet spot: less boilerplate than immediate mode, but you still control the event handling and rendering logic.

== Toolkit DSL

The Toolkit DSL flips the model.
Instead of writing render callbacks, you describe your UI declaratively and let the framework handle the rest.

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=toolkit-app-example]
----

The static import `dev.tamboui.toolkit.Toolkit.*` gives you all the element factories: `text()`, `panel()`, `row()`, `column()`, `columns()`, `list()`, `table()`, and more.

=== Layout

Rows and columns work as you'd expect:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=row-column-layout]
----

For multi-column grid layouts, use `columns()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=columns-layout]
----

CSS properties for columns: `column-count`, `column-order` ("row-first" or "column-first"), `spacing`, `margin`, `flex`.

Use `spacer()` to push things apart:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=spacer-usage]
----

Control positioning with flex:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=flex-positioning]
----

See link:styling.html#_flex_layout[Flex Layout] for detailed documentation on all flex modes and usage patterns.

=== Styling

Style methods chain naturally:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=styling-chain]
----

Panels support border styling:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=panel-border-styling]
----

=== Sizing

Control how elements fill space:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=sizing-options]
----

=== Stateful Widgets

Tables and text inputs need state objects. Lists manage their own state internally:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=stateful-widgets]
----

ListElement provides methods for navigation:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=list-element-navigation]
----

=== Event Handling

Attach handlers to elements:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=event-handling]
----

Return `EventResult.HANDLED` to stop propagation, `UNHANDLED` to let it bubble up.

=== Focus

For Tab/Shift+Tab navigation, elements need both an ID and the focusable flag:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=focus-navigation]
----

The `focusedBorderColor()` method lets you provide visual feedback.

=== Data Visualization

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=data-visualization]
----

=== Wrapping Low-Level Widgets

If you have a custom widget or a widget that doesn't yet have a dedicated Toolkit element, you can wrap it with `widget()`:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=widget-wrapper]
----

This is only useful when:

* You have a custom widget without a dedicated element wrapper
* You want quick integration of a widget into the Toolkit DSL
* You need to apply layout constraints, CSS classes, or event handlers to a widget

**Limitations:**

* **Styling does not propagate** - Colors and modifiers set on the element don't affect the widget's internal rendering.
  The widget renders directly to the buffer using its own styling logic.
* **No CSS child selectors** - GenericWidgetElement has no sub-components that can be styled via CSS.
* **No preferred size** - The element doesn't know the widget's size requirements, so the container must specify constraints.

For full styling support, consider creating a dedicated element wrapper for your widget type (see `TextElement` or `GaugeElement` as examples).

=== Using ToolkitRunner Directly

`ToolkitApp` is convenient, but `ToolkitRunner` gives more control:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=toolkit-runner-direct]
----

=== Fault-Tolerant Rendering

When enabled, fault-tolerant mode catches exceptions from individual elements and displays error placeholders instead of crashing the entire application.
The rest of the UI continues to render normally.

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=fault-tolerant-rendering]
----

With fault-tolerant mode:

* If an element throws during `render()`, an error placeholder is displayed in its area
* The error placeholder shows a red border with the exception type and message
* Other elements continue to render normally
* Useful for dashboards where one failing widget shouldn't break the entire UI

Without fault-tolerant mode (default):

* Exceptions propagate to `TuiRunner`, which displays a full-screen error
* This is the safer default for most applications

=== Example: Todo List

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=todo-app]
----

== Inline Display Mode

The APIs above all use the alternate screen buffer - your application takes over the entire terminal, and the previous content is restored when it exits.

For CLI tools that need to show progress while preserving scroll history, use `InlineDisplay` instead.
This is the pattern used by Gradle, npm, and other build tools: a fixed status area at the bottom while log output scrolls above.

=== When to Use Inline Mode

* Build tools showing compilation progress
* Package managers displaying download status
* Long-running scripts with progress indicators
* Any tool where you want output history preserved

=== Basic Usage

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-display-basic]
----

The display reserves lines at the current cursor position.
When closed, it moves the cursor below and optionally clears the status area.

=== Logging Above the Status Area

Use `println()` to add output that scrolls above the fixed status:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-println]
----

=== Configuration Options

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-display-config]
----

=== Setting Lines Directly

For simple status updates, set lines without a full render:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-set-line]
----

=== Inline vs Alternate Screen

[cols="1,2,2",options="header"]
|===
|Feature |InlineDisplay |TuiRunner / Toolkit

|Screen buffer
|Main buffer (preserved)
|Alternate buffer (replaced)

|Cursor
|Visible
|Hidden

|Terminal capture
|Partial (reserved lines)
|Full terminal

|Previous content
|Preserved above
|Restored on exit

|Best for
|Progress, logs, status
|Interactive full-screen apps
|===

[[inline-tui-runner]]
== Inline TUI Runner

`InlineTuiRunner` adds a managed event loop to inline displays, similar to how `TuiRunner` works for full-screen apps.
It handles keyboard and mouse events, tick-based animations, and thread-safe updates.

=== Basic Usage

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-tui-runner-basic]
----

=== Configuration

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-tui-config]
----

=== Printing Above the Viewport

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-runner-println]
----

=== Thread-Safe Updates

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-thread-safe-updates]
----

[[inline-toolkit]]
== Inline Toolkit

The Inline Toolkit provides the same declarative, element-based API as the full Toolkit DSL, but for inline displays.
This is the recommended approach for most inline applications.

=== InlineApp Base Class

The easiest way to create an inline application:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-app-example]
----

=== Configuration

Override `configure()` to customize behavior:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-app-configure]
----

=== Printing Elements

Print styled content above the viewport:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-print-elements]
----

=== Handling Key Events

Use focusable elements or global key handlers:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-key-handling]
----

=== Text Input in Inline Mode

Text inputs work with proper focus management:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-text-input]
----

=== Using InlineToolkitRunner Directly

For more control, use `InlineToolkitRunner` with a render function:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-toolkit-runner-direct]
----

=== Scopes for Dynamic Regions

Use `scope()` from `InlineToolkit` to create collapsible regions:

[source,java]
----
include::{snippets-dir}/dev/tamboui/docs/snippets/ApiLevelsSnippets.java[tags=inline-scopes]
----

When `downloading` becomes `false`, the scope collapses to zero height and the layout adjusts automatically.

=== Inline vs Full-Screen Toolkit

[cols="1,2,2",options="header"]
|===
|Feature |InlineApp / InlineToolkitRunner |App / ToolkitRunner

|Screen
|Inline (preserves scroll)
|Alternate screen (full takeover)

|Height
|Fixed (specified lines)
|Dynamic (full terminal)

|Output
|`println()` scrolls above
|No scrolling output

|Use case
|Progress, status, forms
|Full interactive applications
|===

== Choosing a Level

**Start with the Toolkit DSL** for most applications.
It handles focus, provides a clean declarative API, and gets you productive quickly.

**Drop to TuiRunner** when you need custom event handling, animations, or want to use the widget layer directly without the Toolkit abstractions.

**Use Immediate Mode** when you're building something unusual - a custom backend, a game engine, or when you want to understand exactly what's happening under the hood.

The levels compose well.
You can use Toolkit elements inside a TuiRunner application, or drop down to direct buffer manipulation when needed.

== Next Steps

* link:bindings.html[Bindings and Actions] - key bindings and action handling
* link:styling.html[CSS Styling] - external stylesheets and theming
* link:mvc-architecture.html[Application Structure] - patterns for larger applications
* link:widgets.html[Widgets Reference] - all available widgets
* link:developer-guide.html[Developer Guide] - building custom widgets
